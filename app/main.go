package main

import (
	"github.com/mattn/go-colorable"
	"github.com/rs/zerolog"
	logger "github.com/rs/zerolog/log"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"os"
	"time"
)

type Config struct {
	WorkdirPath string                     `yaml:"workdir"`
	Structure   []map[string][]interface{} `yaml:"structure"`
}

var tempDirPath string
var config Config

func main() {

	LoadDotEnv("./.env")

	output := zerolog.ConsoleWriter{Out: colorable.NewColorableStdout(), TimeFormat: time.RFC3339}

	output.FormatLevel = func(i interface{}) string {
		if i == nil {
			return ""
		}
		level := i.(string)
		switch level {
		case "info":
			return "\033[32m[ INFO ]\033[0m"
		case "debug":
			return "\033[37m[ DEBUG ]\033[37m"
		case "warn":
			return "\033[33m[ WARN ]\033[33m"
		case "error":
			return "[\033[31m ERROR \033[0m]" // Red color for errors
		default:
			return "[" + level + "]"
		}
	}
	logger.Logger = logger.Output(output)

	// Reading the config file and unmarshalling
	data, err := ioutil.ReadFile(os.Getenv("CONFIG_FILE"))
	checkErr(err, "Error reading file")

	err = yaml.Unmarshal(data, &config)
	checkErr(err, "Error unmarshaling YAML")

	logger.Debug().Msgf("Working directory path is: %v", config.WorkdirPath)
	createInfraStructure(config.WorkdirPath)

	workdirPath := config.WorkdirPath

	srcDir := workdirPath

	if os.Getenv("TEMP_DIR_PATH") != "" {
		tempDirPath = os.Getenv("TEMP_DIR_PATH")
		logger.Debug().Msgf("tempDirPath values is: %v", tempDirPath)
	} else {
		wd, _ := os.Getwd()
		// @TODO add autogenerated timestamp to this working directory in production mode
		tempDirPath = wd + "/../" + "tmp"
		logger.Debug().Msgf("Temporary directory path values is: %v", tempDirPath)
	}

	// Move project to temporary place to not interfere original files
	moveProjectToTemporaryDir(srcDir, tempDirPath, []string{"*.tfstate*", ".terraform"})

	dag, err := buildDAG(workdirPath)
	if err != nil {
		logger.Error().Msgf("Error:", err)
		return
	}

	dag.Print(workdirPath)

	dot := dag.ToDot(workdirPath)
	err = ioutil.WriteFile("dag.dot", []byte(dot), 0644)
	if err != nil {
		logger.Error().Msgf("Error writing DOT file:", err)
		return
	}
	logger.Info().Msgf("DOT file written to dag.dot")

	dag.Apply()

	//for k, v := range dag.nodes {
	//	if len(v) == 0 {
	//		logger.Info().Msgf("Applying... %v", strings.TrimPrefix(k, workdirPath))
	//		// applyTerraform(k, true, true)
	//	} else {
	//		for _, dependentComponent := range v {
	//			logger.Info().Msgf("Applying... %v", strings.TrimPrefix(dependentComponent, workdirPath))
	//			// applyTerraform(dependentComponent, true, true)
	//		}
	//
	//	}
	//}

	//for _, rootComponent := range structure {
	//	for k := range rootComponent {
	//		logger.Debug().Msgf("%s -> %s ", k, rootComponent[k])
	//
	//		rootComponentPath := workdirPath + "/" + k
	//		logger.Debug().Msgf("Processing root components... %v", rootComponentPath)
	//
	//		for _, subComponentElement := range rootComponent[k] {
	//			logger.Debug().Msgf("Processing subcomponent... %v", subComponentElement)
	//
	//			subComponent := fmt.Sprintf("%v", subComponentElement)
	//
	//			// Getting files from each subdirectory and checking cross dependencies
	//			files := GetTerraformFiles(rootComponentPath + "/" + subComponent)
	//
	//			for _, v := range files {
	//				dependencies := GetDependency(v)
	//				if len(dependencies) != 0 {
	//					for _, v1 := range dependencies {
	//						refModule, _ := extractRefModuleFromString(v1)
	//
	//						q.Enqueue(refModule)
	//						q.Enqueue(subComponent)
	//					}
	//				}
	//			}
	//
	//		}
	//
	//	}
	//}

	//components := []string{}
	//for _, v := range q.elements {
	//	components = append(components, GetChildDirectory(v))
	//}
	//
	//logger.Info().Msgf("Pending apply: %v", strings.Join(components, ","))
	//
	//for _, v := range q.elements {
	//
	//	logger.Info().Msgf("In queue now: %v ", GetChildDirectory(v))
	//	//applyTerraform(v, true, true)
	//}

}
